{% extends 'base.html' %}
{% block content %}
<div class="container mt-4">
  <h2 class="mb-3">Connections</h2>

<div class="row mb-4 align-items-center">
  <!-- Totals (left, larger) -->
  <div class="col-lg-8 col-md-7 mb-3 mb-md-0">
    <div id="totals" class="text-muted">
      <strong>Totals:</strong>
      Sent <span id="total-sent">{{ totals.total_sent | human_readable }}</span>,
      Received <span id="total-recv">{{ totals.total_received | human_readable }}</span><br>
      <strong>This month:</strong>
      Sent <span id="month-sent">{{ monthly_totals.month_sent | human_readable }}</span>,
      Received <span id="month-recv">{{ monthly_totals.month_received | human_readable }}</span>
    </div>
  </div>

  <!-- Bar chart (right, smaller) -->
  <div class="col-lg-4 col-md-5">
    <div class="card shadow-sm border-secondary">
      <div class="card-body p-2">
        <div class="text-muted small mb-2">Data Usage</div>
        <canvas id="usageChart" height="120"></canvas>
      </div>
    </div>
  </div>
</div>

  <!-- Connections Table -->
  <div class="table-responsive mb-4">
    <table class="table table-striped table-bordered table-hover">
      <thead class="table-dark">
        <tr>
          <th>Timestamp</th>
          <th>User</th>
          <th>Client IP</th>
          <th>Destination</th>
          <th>Status</th>
          <th>Bytes Sent</th>
          <th>Bytes Received</th>
        </tr>
      </thead>
      <tbody>
        {% for r in rows %}
          <tr>
            <td>{{ r.ts }}</td>
            <td>{{ r.username }}</td>
            <td>{{ r.client_ip }}</td>
            <td>{{ r.destination }}</td>
            <td>
              {% if r.status.lower() == 'success' %}
                <span class="badge bg-success">{{ r.status }}</span>
              {% elif r.status.lower() == 'failed' %}
                <span class="badge bg-danger">{{ r.status }}</span>
              {% elif r.status.lower() == 'pending' %}
                <span class="badge bg-warning text-dark">{{ r.status }}</span>
              {% else %}
                <span class="badge bg-secondary">{{ r.status }}</span>
              {% endif %}
            </td>
            <td>{{ r.bytes_sent | human_readable }}</td>
            <td>{{ r.bytes_received | human_readable }}</td>
          </tr>
        {% endfor %}
      </tbody>
    </table>
  </div>

  <nav aria-label="Page navigation" class="mb-4">
    <ul class="pagination justify-content-center">
      {% if page > 1 %}
        <li class="page-item">
          <a class="page-link" href="{{ url_for('list_connections', page=page-1) }}">Previous</a>
        </li>
      {% else %}
        <li class="page-item disabled">
          <span class="page-link">Previous</span>
        </li>
      {% endif %}
      <li class="page-item disabled">
        <span class="page-link">Page {{ page }} of {{ total_pages }}</span>
      </li>
      {% if page < total_pages %}
        <li class="page-item">
          <a class="page-link" href="{{ url_for('list_connections', page=page+1) }}">Next</a>
        </li>
      {% else %}
        <li class="page-item disabled">
          <span class="page-link">Next</span>
        </li>
      {% endif %}
    </ul>
  </nav>
</div>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
const ctx = document.getElementById('usageChart');
let usageChart = null;

async function fetchUsageData() {
  const res = await fetch("{{ url_for('connections_stats') }}");
  if (!res.ok) throw new Error('Failed to fetch usage data');
  return await res.json();
}

function humanReadable(value) {
  const units = ['B','KB','MB','GB','TB'];
  let size = value;
  let unit = units[0];
  for (let i=0; i<units.length-1 && size>=1000; i++) {
    size /= 1000;
    unit = units[i+1];
  }
  return { value: size, unit };
}

async function renderUsageChart() {
  const data = await fetchUsageData();

  const totalSent = data.total_sent;
  const totalReceived = data.total_received;
  const monthSent = data.month_sent;
  const monthReceived = data.month_received;

  const maxValue = Math.max(totalSent, totalReceived, monthSent, monthReceived);
  const { unit } = humanReadable(maxValue);
  const scale = { 'B':1,'KB':1e3,'MB':1e6,'GB':1e9,'TB':1e12 }[unit];

  const chartData = {
    labels: ['Sent','Received'],
    datasets: [
      {
        label: 'Total (' + unit + ')',
        data: [totalSent/scale, totalReceived/scale],
        backgroundColor: 'rgba(25,135,84,0.7)'
      },
      {
        label: 'This Month (' + unit + ')',
        data: [monthSent/scale, monthReceived/scale],
        backgroundColor: 'rgba(13,110,253,0.7)'
      }
    ]
  };

  if (usageChart) usageChart.destroy();

  usageChart = new Chart(ctx, {
    type: 'bar',
    data: chartData,
    options: {
      responsive: true,
      plugins: {
        legend: { position: 'bottom' },
        tooltip: {
          callbacks: {
            label: ctx => ctx.dataset.label + ': ' + ctx.parsed.y.toFixed(2) + ' ' + unit
          }
        }
      },
      scales: {
        y: {
          beginAtZero: true,
          title: { display: true, text: 'Data (' + unit + ')' }
        },
        x: {
          title: { display: true, text: 'Category' }
        }
      }
    }
  });
}

document.addEventListener('DOMContentLoaded', renderUsageChart);

// Update totals every 30s
async function updateConnectionStats() {
  try {
    const res = await fetch("{{ url_for('connections_stats') }}");
    if (!res.ok) return;
    const data = await res.json();
    const humanReadableValue = v => { if(v<1000)return v+" B"; const units=["KB","MB","GB","TB"]; let size=v; for(const u of units){ if(size<1000) return size.toFixed(2)+" "+u; size/=1000;} return size.toFixed(2)+" PB"; };
    document.getElementById("total-sent").textContent = humanReadableValue(data.total_sent);
    document.getElementById("total-recv").textContent = humanReadableValue(data.total_received);
    document.getElementById("month-sent").textContent = humanReadableValue(data.month_sent);
    document.getElementById("month-recv").textContent = humanReadableValue(data.month_received);

    renderUsageChart(); // refresh chart with updated data
  } catch(err){ console.warn("Failed to update connection stats:", err);}
}
setInterval(updateConnectionStats, 30000);
</script>
{% endblock %}
